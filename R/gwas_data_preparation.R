#' @title Cleaning GWAS summary data for colocalization
#'
#' @description This function prepares GWAS summary statistics for subsequent colocalization analyses.
#' Upon execution, it extracts variants from the full GWAS summary statistics located within flanking regions (Â±500KB) centered on each nominated SNP defined in `SNP_data`.
#' The processed data is saved as individual text files in the \code{save_folder/${pheno}} directory, named after the specific causal SNP (e.g., \code{rs12345.txt}).
#'
#' Please ensure that the gphysical positions in the input `SNP_data_create_above` and the raw GWAS summary statistics are aligned to the \strong{same reference genome build} (e.g., both hg19 or both hg38) to ensure accurate mapping.
#'
#' @details
#' The input GWAS summary data must contain at least: **SNP, CHR, BP**.
#'
#' **For Quantitative Traits (`gwas_data_type = "quant"`):**
#' * **With sdY (Phenotype Standard Deviation), Beta, SE:** Requires `BETA`, `SE`.
#' * **With sdY, without Beta/SE:** Requires `P`, `MAF`.
#' * **Without sdY, with Beta/SE:** Requires `BETA`, `SE`, `MAF`.
#' * **Without sdY, without Beta/SE:** Requires `P`, `MAF`.
#'
#' **For Case-Control Traits (`gwas_data_type = "cc"`):**
#' * **With Beta/SE:** Requires `BETA`, `SE`.
#' * **Without Beta/SE:** Requires `P`, `MAF`.
#'
#' **Note on Harmonization:**
#' To ensure the effect alleles are aligned between GWAS and eQTL datasets, set `gwas_allele_input = TRUE`. This will further require `A1` (effect allele) and `A2` (other allele) columns.
#'
#' @param pheno_name Character string or vector. The name(s) of the phenotype(s) to process. Can be comma-separated.
#' @param SNP_data_create_above Character string. File path to the SNP mapping data.
#'   This specifically refers to the **"SNP_data_for_coloc.csv"** file generated by the \code{nominated_gene_extract} function.
#' @param gwas_data_folder Character string. Path to the directory containing raw GWAS summary files.
#' @param gwas_data_suffix Character string. The file suffix for the raw GWAS summary statistics (e.g., ".txt", ".summary").
#'   In multi-phenotype analysis, all files must share the same suffix.
#'   The function expects filenames to strictly follow the format: \code{paste0(pheno, suffix)}.
#'   \strong{Note:} The input GWAS summary statistics must contain \code{SNP}, \code{CHR}, and \code{BP} columns.
#'   Additional columns are required depending on input parameters; please refer to the \strong{Details} section.
#'   Column names must be strictly matched; the column order does not matter.
#' @param gwas_allele_input Logical. Whether to include allele columns (A1, A2) for strand alignment.
#' @param gwas_data_type Character string. One of "quant" (quantitative) or "cc" (case-control).
#' @param gwas_sdy_input Logical (optional). Required if `gwas_data_type = "quant"`. Whether the phenotype standard deviation (sdY) is available/provided in later steps.
#' @param gwas_s_input Logical (optional). Required if `gwas_data_type = "cc"`. Whether the proportion of cases (s) is provided.
#' @param gwas_beta_input Logical. Whether the GWAS summary data contains Beta and Standard Error columns.
#' @param save_folder Character string. Path to the output directory.
#'
#' @return None. The function saves processed files to the `save_folder`.
#' @export
#' @importFrom data.table fread fwrite setDT as.data.table
#' @importFrom rlang abort inform
#' @importFrom dplyr filter
gwas_data_preparation <- function(pheno_name,
                                  SNP_data_create_above,
                                  gwas_data_folder,
                                  gwas_data_suffix,
                                  gwas_allele_input,
                                  gwas_data_type,
                                  gwas_sdy_input = NULL,
                                  gwas_s_input = NULL,
                                  gwas_beta_input,
                                  save_folder) {

  # --- 1. Input Validation & Standardization ---

  # Check pheno_name
  pheno_name <- validate_pheno_name(pheno_name)
  rlang::inform(
    message = c(
      "i" = paste0("Phenotypes to be analyzed (", length(pheno_name), "):"),
      " " = paste(pheno_name, collapse = ", ")
    )
  )

  # Check SNP_data file
  if (missing(SNP_data_create_above) || !file.exists(SNP_data_create_above)) {
    rlang::abort(paste0("SNP_data file not found: ", SNP_data_create_above))
  }

  SNP_data <- data.table::fread(SNP_data_create_above, stringsAsFactors = FALSE)

  expected_cols <- c("SNP", "CHR", "BP", "START", "END", "GENE1", "GENE2", "GENE3", "GENE4", "GENE5", "GENE6", "PHENO")
  missing_cols <- setdiff(expected_cols, colnames(SNP_data))
  if (length(missing_cols) > 0) {
    rlang::abort(paste0("SNP_data is missing required columns: ", paste(missing_cols, collapse = ", ")))
  }

  # Filter rows where all GENE1-6 are "NONE"
  n_none <- rowSums(SNP_data[, paste0("GENE", 1:6)] == "NONE", na.rm = TRUE)
  rows_to_keep <- n_none < 6
  n_dropped <- sum(!rows_to_keep)

  if (n_dropped > 0) {
    SNP_data <- SNP_data[rows_to_keep, ]
  }

  if (nrow(SNP_data) == 0) {
    rlang::abort("SNP_data is empty after filtering non-mapping SNPs. No regions to process.")
  }

  # Check phenotype presence in SNP_data
  missing_phenos <- setdiff(pheno_name, unique(SNP_data$PHENO))
  if (length(missing_phenos) > 0) {
    rlang::abort(paste0("Phenotypes missing in SNP_data PHENO column: ", paste(missing_phenos, collapse = ", ")))
  }

  # Check folders
  if (!dir.exists(gwas_data_folder)) rlang::abort("gwas_data_folder does not exist.")
  if (!dir.exists(save_folder)) rlang::abort("save_folder does not exist.")
  if (file.access(save_folder, 2) != 0) rlang::abort("No write permission for save_folder.")

  gwas_data_folder <- normalizePath(gwas_data_folder)
  save_folder <- normalizePath(save_folder)

  # Check suffix
  if (!is.character(gwas_data_suffix) || length(gwas_data_suffix) != 1) {
    rlang::abort("'gwas_data_suffix' must be a single string.")
  }

  # Check Booleans
  if (!is.logical(gwas_allele_input)) rlang::abort("'gwas_allele_input' must be TRUE/FALSE.")
  if (!is.logical(gwas_beta_input)) rlang::abort("'gwas_beta_input' must be TRUE/FALSE.")
  if (!gwas_data_type %in% c("quant", "cc")) rlang::abort("'gwas_data_type' must be 'quant' or 'cc'.")

  # Logic checks for sdy and s inputs
  if (gwas_data_type == "quant") {
    if (is.null(gwas_sdy_input)) rlang::abort("For quant traits, 'gwas_sdy_input' cannot be NULL.")
    if (!is.null(gwas_s_input)) rlang::abort("For quant traits, 'gwas_s_input' must be NULL.")
  } else { # cc
    if (is.null(gwas_s_input)) rlang::abort("For cc traits, 'gwas_s_input' cannot be NULL.")
    if (!is.null(gwas_sdy_input)) rlang::abort("For cc traits, 'gwas_sdy_input' must be NULL.")
  }

  # --- 2. Processing Loop ---

  for (pheno in pheno_name) {
    rlang::inform(paste0("Processing phenotype: ", pheno))

    # Filter SNP definitions for current phenotype
    current_SNP_data <- SNP_data[SNP_data$PHENO == pheno, ]

    # Define input file path
    gwas_file <- file.path(gwas_data_folder, paste0(pheno, gwas_data_suffix))
    if (!file.exists(gwas_file)) {
      rlang::abort(paste0("GWAS summary file missing: ", gwas_file))
    }

    # Call internal worker function
    process_single_gwas(
      pheno = pheno,
      SNP_data = current_SNP_data,
      gwas_file_path = gwas_file,
      gwas_allele_input = gwas_allele_input,
      gwas_data_type = gwas_data_type,
      gwas_sdy_input = gwas_sdy_input,
      gwas_beta_input = gwas_beta_input,
      save_folder = save_folder
    )

    rlang::inform(paste0("Completed: ", pheno))
  }
}

#' Internal worker function to process a single GWAS file
#' @noRd
process_single_gwas <- function(pheno, SNP_data, gwas_file_path, gwas_allele_input,
                                gwas_data_type, gwas_sdy_input, gwas_beta_input, save_folder) {

  gwas_dt <- data.table::fread(gwas_file_path)

  # --- Column Mapping ---
colname_map <- list(
  SNP  = "snp",
  CHR  = "chr",
  BP   = "bp",
  MAF  = "maf",
  BETA = "beta",
  SE   = "se",
  P    = "p",
  A1   = "a1",
  A2   = "a2"
)

  # Standardize columns
  current_cols <- colnames(gwas_dt)
  current_cols_lower <- tolower(current_cols)

  for (std_col in names(colname_map)) {
    matches <- which(current_cols_lower %in% colname_map[[std_col]])
    if (length(matches) > 0) {
      data.table::setnames(gwas_dt, current_cols[matches[1]], std_col)
    }
  }

  # --- Determine Required Columns ---
  req_cols <- c("SNP", "CHR", "BP")

  if (gwas_data_type == "quant") {
    # Logic: If we have Beta/SE, we prefer them. If no sdy is coming later, we usually need MAF too.
    # Following the original logic strictly:
    if (gwas_sdy_input && gwas_beta_input) {
      req_cols <- c(req_cols, "BETA", "SE")
    } else if (!gwas_sdy_input && gwas_beta_input) {
      req_cols <- c(req_cols, "BETA", "SE", "MAF")
    } else {
      # No Beta/SE provided -> need P and MAF
      req_cols <- c(req_cols, "P", "MAF")
    }
  } else { # cc
    if (gwas_beta_input) {
      req_cols <- c(req_cols, "BETA", "SE")
    } else {
      req_cols <- c(req_cols, "P", "MAF")
    }
  }

  if (gwas_allele_input) {
    req_cols <- c(req_cols, "A1", "A2")
  }

  # Check missing columns
  missing_cols <- setdiff(req_cols, colnames(gwas_dt))
  if (length(missing_cols) > 0) {
    rlang::abort(paste0("Missing required columns in GWAS file: ", paste(missing_cols, collapse = ", ")))
  }

  # Subset columns
  gwas_dt <- gwas_dt[, ..req_cols]

  # Normalize MAF if present (ensure minor allele freq <= 0.5)
  if ("MAF" %in% names(gwas_dt)) {
    gwas_dt[MAF > 0.5, MAF := 1 - MAF]
  }

  # --- Output Generation (Optimized) ---
  out_dir <- file.path(save_folder, pheno)
  if (!dir.exists(out_dir)) dir.create(out_dir, recursive = TRUE)

  # Ensure columns are correct types for filtering
  gwas_dt[, `:=`(CHR = as.character(CHR), BP = as.numeric(BP))]
  SNP_data$CHR <- as.character(SNP_data$CHR)

  # Split logic: Iterate by unique chromosome to avoid scanning full dataset repeatedly
  unique_chrs <- unique(SNP_data$CHR)

  for (chrom in unique_chrs) {
    # Extract GWAS subset for this chromosome
    gwas_chr_subset <- gwas_dt[CHR == chrom]

    # Get regions on this chromosome
    snp_regions_chr <- SNP_data[SNP_data$CHR == chrom, ]

    # Iterate through regions
    # Using a simple loop here is fine as N regions per chromosome is usually manageable
    for (i in seq_len(nrow(snp_regions_chr))) {
      region_row <- snp_regions_chr[i, ]

      # Filter
      filtered_dat <- gwas_chr_subset[BP >= region_row$START & BP <= region_row$END]

      # Write
      if (nrow(filtered_dat) > 0) {
        outfile <- file.path(out_dir, paste0(region_row$SNP, ".txt"))
        data.table::fwrite(filtered_dat, file = outfile, sep = "\t", quote = FALSE)
      }
    }
  }
}
