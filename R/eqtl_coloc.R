#' @title Colocalization-based linking
#'
#' @description This function utilizes `coloc::coloc.abf` to perform colocalization analysis between eQTL and GWAS summary statistics.
#' It harmonizes strands, aligns effect alleles, and computes posterior probabilities for hypothesis H4.
#'
#' @param pheno_name Character vector. Phenotypes to be analyzed.
#' @param SNP_data_create_above Character string. File path to the SNP mapping data.
#'   This specifically refers to the **"SNP_data_for_coloc.csv"** file generated by the \code{nominated_gene_extract} function.
#' @param gwas_separate_data_folder Character string. Directory containing processed GWAS summary statistics (organized by Phenotype).
#' @param eqtl_separate_data_folder Character string. Directory containing processed eQTL summary statistics (organized by Tissue).
#' @param strand_harmonize Logical. Whether to perform strand alignment (requires A1/A2 columns).
#' @param gwas_data_type Character string. "quant" or "cc".
#' @param gwas_sdy_input Logical. Required for "quant". Whether sdY is available.
#' @param gwas_sdy_data Character string. Path to a CSV or text file containing the standard deviation of the phenotype.
#'   Required if `gwas_sdy_input = TRUE`. The file must include a header with the following two columns:
#'   \itemize{
#'     \item **PHENO**: The phenotype name (must match values in `pheno_name`).
#'     \item **SDY**: The numeric standard deviation of the phenotype.
#'   }
#'
#' @param gwas_s_data Character string. Path to a CSV or text file containing the proportion of cases (s) for case-control studies.
#'   Required if `gwas_data_type = "cc"`. The file must include a header with the following two columns:
#'   \itemize{
#'     \item **PHENO**: The phenotype name (must match values in `pheno_name`).
#'     \item **S**: The proportion of samples that are cases (calculated as \eqn{N_{cases} / N_{total}}, value between 0 and 1).
#'   }
#'
#' @param gwas_beta_input Logical. Whether GWAS data contains Beta/SE (TRUE) or only P/MAF (FALSE).
#' @param gwas_n_data Character string. Path to a CSV or text file containing GWAS sample sizes.
#'   Required if `gwas_data_type = "quant"` and `gwas_sdy_input = FALSE`. The file must include a header with the following two columns:
#'   \itemize{
#'     \item **PHENO**: The phenotype name (must match values in `pheno_name`).
#'     \item **N**: The total sample size of the GWAS.
#'   }
#' @param eqtl_n_data Character string or NULL. Path to a CSV or text file containing eQTL sample sizes.
#'   \itemize{
#'     \item If you are using standard **GTEx V8** or **eQTLGen Phase 1** data, you do **not** need to provide this parameter (keep it `NULL`). The function will automatically use the internal reference sample sizes.
#'     \item If you are using eQTL data from other sources, you must provide a file including a header with the following two columns:
#'     \itemize{
#'       \item **TISSUE**: The tissue name (must match the folder names in `eqtl_separate_data_folder`).
#'       \item **N**: The sample size of the eQTL study for that tissue.
#'     }
#'   }
#' @param save_folder Character string. Output directory.
#' @param work_part Character string (e.g., "1/10"). Splits the job into parts for parallel execution.
#' @param coloc_p1 Numeric. Prior probability a SNP is associated with trait 1. Default 1e-4.
#' @param coloc_p2 Numeric. Prior probability a SNP is associated with trait 2. Default 1e-4.
#' @param coloc_p12 Numeric. Prior probability a SNP is associated with both traits. Default 1e-5.
#'
#' @return None. Saves "coloc.csv" and "coloc_SNP.csv" to `save_folder`.
#' @export
#' @importFrom data.table fread rbindlist
#' @importFrom dplyr bind_rows
#' @importFrom rlang abort inform warn
#' @importFrom coloc coloc.abf
eqtl_coloc <- function(pheno_name,
                       SNP_data_create_above,
                       gwas_separate_data_folder,
                       eqtl_separate_data_folder,
                       strand_harmonize,
                       gwas_data_type,
                       gwas_sdy_input = NULL,
                       gwas_sdy_data = NULL,
                       gwas_s_data = NULL,
                       gwas_beta_input,
                       gwas_n_data = NULL,
                       eqtl_n_data = NULL,
                       save_folder,
                       work_part = NULL,
                       coloc_p1 = 1e-4,
                       coloc_p2 = 1e-4,
                       coloc_p12 = 1e-5) {

  # --- 1. Input Validation & Preparation ---

  # 1.1 Phenotypes
  pheno_name <- validate_pheno_name(pheno_name)
  rlang::inform(c("i" = paste0("Phenotypes to analyze (", length(pheno_name), "): "), " " = paste(pheno_name, collapse = ", ")))

  # 1.2 SNP Data
  if (missing(SNP_data_create_above) || !file.exists(SNP_data_create_above)) rlang::abort("SNP_data file not found.")
  SNP_data <- data.table::fread(SNP_data_create_above, data.table = FALSE)

  # Ensure GENE columns exist (GENE1-6)
  gene_cols <- paste0("GENE", 1:6)
  expected_cols <- c("SNP", "CHR", "BP", "START", "END", gene_cols, "PHENO")
  missing_cols <- setdiff(expected_cols, colnames(SNP_data))
  if (length(missing_cols) > 0) rlang::abort(paste0("SNP_data missing columns: ", paste(missing_cols, collapse = ", ")))

  # Check phenotype consistency
  missing_phenos <- setdiff(pheno_name, unique(SNP_data$PHENO))
  if (length(missing_phenos) > 0) rlang::abort(paste0("Phenotypes missing in SNP_data: ", paste(missing_phenos, collapse = ", ")))

  # 1.3 Folders
  if (!dir.exists(gwas_separate_data_folder)) rlang::abort("gwas_separate_data_folder not found.")
  if (!dir.exists(eqtl_separate_data_folder)) rlang::abort("eqtl_separate_data_folder not found.")

  tissue_list <- list.dirs(eqtl_separate_data_folder, recursive = FALSE, full.names = FALSE)
  if (length(tissue_list) == 0) {
    rlang::abort(c(
      "No eQTL tissue data found.",
      "x" = paste0("The directory '", eqtl_separate_data_folder, "' contains no subfolders."),
      "i" = "Please check the input path. The eQTL data must be organized into subfolders (one per tissue)."
    ))
  }
  rlang::inform(paste0("i Found ", length(tissue_list), " eQTL tissues."))

  if (!dir.exists(save_folder)) dir.create(save_folder, recursive = TRUE)
  if (file.access(save_folder, 2) != 0) rlang::abort("No write permission for save_folder.")

  # 1.4 Work Part (Job Splitting)
  if (!is.null(work_part)) {
    parts <- as.numeric(unlist(strsplit(work_part, "/")))
    if (length(parts) != 2 || any(is.na(parts))) rlang::abort("work_part must be format as '1/10'")
    SNP_data <- split(SNP_data, sort(rep(1:parts[2], length.out = nrow(SNP_data))))[[parts[1]]]
    rlang::inform(paste0("i Running job part ", parts[1], " of ", parts[2], " (", nrow(SNP_data), " SNPs)"))
  }

  # 1.5 Load Aux Data (sdY, N, S)
  # Helper to load key-value files
  load_kv_data <- function(path, col_k, col_v, name) {
    if (is.null(path) || !file.exists(path)) rlang::abort(paste0(name, " file missing: ", path))
    df <- data.table::fread(path, data.table = FALSE)
    colnames(df) <- toupper(colnames(df))
    if (!all(c(col_k, col_v) %in% colnames(df))) rlang::abort(paste0(name, " must contain columns ", col_k, " and ", col_v))
    setNames(df[[col_v]], df[[col_k]])
  }

  # Load specific data based on type
  sdy_map <- NULL
  n_map <- NULL
  s_map <- NULL

  if (gwas_data_type == "quant") {
    if (isTRUE(gwas_sdy_input)) {
      sdy_map <- load_kv_data(gwas_sdy_data, "PHENO", "SDY", "gwas_sdy_data")
    } else {
      n_map <- load_kv_data(gwas_n_data, "PHENO", "N", "gwas_n_data")
    }
  } else if (gwas_data_type == "cc") {
    s_map <- load_kv_data(gwas_s_data, "PHENO", "S", "gwas_s_data")
  }

  # Load eQTL sample sizes
  if (is.null(eqtl_n_data)) {
    eqtl_n_path <- system.file("extdata", "eqtl_samplesize.csv.gz", package = "mds2g") # Assuming package name
  } else {
    eqtl_n_path <- eqtl_n_data
  }
  eqtl_n_map <- load_kv_data(eqtl_n_path, "TISSUE", "N", "eqtl_n_data")

  # --- 2. Define Required Columns & Logic ---

  # Base GWAS columns
  req_gwas_cols <- c("SNP", "CHR", "BP")
  if (gwas_beta_input) {
    req_gwas_cols <- c(req_gwas_cols, "BETA", "SE")
    if (gwas_data_type == "quant" && isFALSE(gwas_sdy_input)) req_gwas_cols <- c(req_gwas_cols, "MAF")
  } else {
    req_gwas_cols <- c(req_gwas_cols, "P", "MAF")
  }
  if (strand_harmonize) req_gwas_cols <- c(req_gwas_cols, "A1", "A2")

  # --- 3. Main Processing Loop ---

  # Use lists to store results (more efficient than rbind inside loop)
  res_summary_list <- list()
  res_snp_list <- list()

  # Counter for logging
  counter <- 0
  total_snps <- nrow(SNP_data)

  # Loop 1: Iterate SNPs (Outer Loop)
  # Rationale: GWAS files are organized by Pheno/SNP. Reading GWAS is the bottleneck.
  # Read GWAS once, then match against all Tissues/Genes.

  for (i in seq_len(total_snps)) {
    counter <- counter + 1
    if (counter %% 10 == 0) message(paste0("Processing SNP ", counter, " / ", total_snps, "..."))

    current_pheno <- SNP_data$PHENO[i]
    current_snp   <- SNP_data$SNP[i]

    # Identify valid genes (not NONE)
    valid_genes <- unlist(SNP_data[i, gene_cols])
    valid_genes <- valid_genes[valid_genes != "NONE" & !is.na(valid_genes)]
    if (length(valid_genes) == 0) next

    # 3.1 Read GWAS Data
    gwas_file <- file.path(gwas_separate_data_folder, current_pheno, paste0(current_snp, ".txt"))
    if (!file.exists(gwas_file)) {
      # warning(paste("GWAS file missing:", gwas_file))
      next
    }

    gwas_df <- tryCatch(data.table::fread(gwas_file, sep="\t", data.table=FALSE), error=function(e) NULL)
    if (is.null(gwas_df) || nrow(gwas_df) == 0) next

    # Validate GWAS columns
    if (!all(req_gwas_cols %in% colnames(gwas_df))) {
      warning(paste0("GWAS file missing columns: ", current_snp))
      next
    }

    # Pre-process GWAS
    gwas_df <- gwas_df[!is.na(gwas_df$SNP) & trimws(gwas_df$SNP) != "", ]

    if (any(duplicated(gwas_df$SNP))) {
      if ("P" %in% colnames(gwas_df)) {
        gwas_df <- gwas_df[order(gwas_df$P), ]
      } else if ("BETA" %in% colnames(gwas_df) && "SE" %in% colnames(gwas_df)) {
        safe_se <- gwas_df$SE
        safe_se[safe_se == 0] <- 1e-6
        z_score <- abs(gwas_df$BETA / safe_se)
        gwas_df <- gwas_df[order(z_score, decreasing = TRUE), ]
      }
      gwas_df <- gwas_df[!duplicated(gwas_df$SNP), ]
    }

    # Loop 2: Iterate Tissues
    for (tissue in tissue_list) {
      tissue_n <- eqtl_n_map[[tissue]]
      if (is.null(tissue_n)) next # Skip if no sample size info

      # Loop 3: Iterate Genes
      for (gene in valid_genes) {

        # 3.2 Read eQTL Data
        eqtl_file <- file.path(eqtl_separate_data_folder, tissue, "separate_file", paste0(tissue, "_", gene, ".txt"))
        if (!file.exists(eqtl_file)) {
          message(paste("  [SKIP] eQTL file missing:", tissue, gene))
          next
        }

        eqtl_df <- tryCatch(data.table::fread(eqtl_file, sep="\t", header=TRUE, data.table=FALSE), error=function(e) NULL)
        if (is.null(eqtl_df) || nrow(eqtl_df) == 0) {
          message(paste("  [SKIP] eQTL data empty:", tissue, gene))
          next
        }

        ##qc
        eqtl_df <- eqtl_df[!is.na(eqtl_df$SNP) & trimws(eqtl_df$SNP) != "", ]
        if (any(duplicated(eqtl_df$SNP))) {
          if ("P" %in% colnames(eqtl_df)) {
            eqtl_df <- eqtl_df[order(eqtl_df$P), ]
          } else if ("BETA" %in% colnames(eqtl_df) && "SE" %in% colnames(eqtl_df)) {
            safe_se <- eqtl_df$SE
            safe_se[safe_se == 0] <- 1e-6
            z_score <- abs(eqtl_df$BETA / safe_se)
            eqtl_df <- eqtl_df[order(z_score, decreasing = TRUE), ]
          }
          eqtl_df <- eqtl_df[!duplicated(eqtl_df$SNP), ]
        }

        # 3.3 Merge & Filter
        # Note: Using inner join by SNP
        merged_df <- merge(gwas_df, eqtl_df, by = "SNP", suffixes = c("_gwas", "_eqtl"))
        if (nrow(merged_df) == 0) {
          message(paste0("  [SKIP] Merge resulted in 0 rows. ",
                         "Pheno: ", current_pheno,
                         " | SNP: ", current_snp,
                         " | Tissue: ", tissue,
                         " | Gene: ", gene))
          next
        }

        merged_df <- merged_df[!duplicated(merged_df$SNP), ]

        # Check MAF_eqtl existence/validity
        if (!"MAF_eqtl" %in% colnames(merged_df) || all(is.na(merged_df$MAF_eqtl))) next
        merged_df <- merged_df[!is.na(merged_df$MAF_eqtl), ]
        if (nrow(merged_df) == 0) next

        # Clean Zeros in MAF (coloc crashes with MAF=0)
        if ("MAF_gwas" %in% colnames(merged_df)) merged_df$MAF_gwas[merged_df$MAF_gwas == 0] <- 0.001
        merged_df$MAF_eqtl[merged_df$MAF_eqtl == 0] <- 0.001

        # Harmonize Strands
        if (strand_harmonize) {
          merged_df <- harmonize_data(merged_df)
          if (nrow(merged_df) == 0) next
        }

        # 3.4 Construct Coloc Datasets
        # Ensure BETA column naming consistency for eQTL (some files might just have 'BETA')
        if ("BETA" %in% colnames(merged_df) && !"BETA_eqtl" %in% colnames(merged_df)) {
          merged_df$BETA_eqtl <- merged_df$BETA
        }

        # Calculate VarBeta if needed
        if ("SE_eqtl" %in% colnames(merged_df)) merged_df$varbeta_eqtl <- merged_df$SE_eqtl^2
        if ("SE_gwas" %in% colnames(merged_df)) merged_df$varbeta_gwas <- merged_df$SE_gwas^2

        # --- Build GWAS List ---
        d_gwas <- list(type = gwas_data_type, snp = merged_df$SNP)

        if (gwas_beta_input) {
          d_gwas$beta <- merged_df$BETA_gwas
          d_gwas$varbeta <- merged_df$varbeta_gwas
          d_gwas$MAF <- merged_df$MAF_gwas
        } else {
          d_gwas$pvalues <- merged_df$P_gwas
          d_gwas$MAF <- merged_df$MAF_gwas
        }

        if (gwas_data_type == "quant") {
          if (isTRUE(gwas_sdy_input)) {
            d_gwas$sdY <- sdy_map[[current_pheno]]
          } else {
            d_gwas$N <- n_map[[current_pheno]]
          }
        } else {
          # CC
          d_gwas$s <- s_map[[current_pheno]]
          # Note: Coloc usually requires N for CC if using P-values, usually implicit or should be added if beta input is FALSE
          # If beta_input=TRUE, SE includes N info. If beta_input=FALSE, N is needed?
          # Assuming N is not strictly needed for CC if s is provided with beta/se, but with P-values usually N is needed.
          # For robustness, if we have N map available, use it, otherwise rely on coloc defaults.
          # Based on user's original code, N was not passed for CC.
        }

        # --- Build eQTL List (Always Quant, Always Beta/SE) ---
        d_eqtl <- list(
          beta = merged_df$BETA_eqtl,
          varbeta = merged_df$varbeta_eqtl,
          N = tissue_n,
          type = "quant",
          MAF = merged_df$MAF_eqtl,
          snp = merged_df$SNP
        )

        # 3.5 Run Coloc
        coloc_res <- tryCatch({
          coloc::coloc.abf(d_gwas, d_eqtl, p1 = coloc_p1, p2 = coloc_p2, p12 = coloc_p12)
        }, error = function(e) NULL)

        if (is.null(coloc_res)) next

        # 3.6 Store Results
        summ <- as.list(coloc_res$summary)
        summ$PHENO <- current_pheno
        summ$SNP <- current_snp
        summ$GENE <- gene
        summ$TISSUE <- tissue

        res_summary_list[[length(res_summary_list) + 1]] <- summ

        # Store detailed SNP results if H4 is high
        if (summ$PP.H4.abf >= 0.8) {
          snp_dets <- coloc_res$results
          snp_dets <- snp_dets[snp_dets$SNP.PP.H4 >= 0.8, ]
          if (nrow(snp_dets) > 0) {
            snp_dets$PHENO <- current_pheno
            snp_dets$SNP_Region <- current_snp # Rename to avoid confusion with SNP column
            snp_dets$GENE <- gene
            snp_dets$TISSUE <- tissue
            res_snp_list[[length(res_snp_list) + 1]] <- snp_dets
          }
        }

      } # End Gene
    } # End Tissue
  } # End SNP

  # --- 4. Final Output ---

  # Bind Results
  final_coloc <- dplyr::bind_rows(res_summary_list)
  final_snp   <- dplyr::bind_rows(res_snp_list)

  # Deduplicate
  if (nrow(final_coloc) > 0) final_coloc <- unique(final_coloc)
  if (nrow(final_snp) > 0) final_snp <- unique(final_snp)

  # Filter H4 >= 0.8 for summary (as per user request at the end of original code)
  if (nrow(final_coloc) > 0) {
    # Note: col name is PP.H4.abf usually, accessing by index 6 is risky but kept logic
    if("PP.H4.abf" %in% names(final_coloc)) {
      final_coloc <- final_coloc[final_coloc$PP.H4.abf >= 0.8, ]
    }
  }

  # Write
  suffix <- if (!is.null(work_part)) paste0("_part_", parts[1]) else ""

  out_coloc <- file.path(save_folder, paste0("coloc", suffix, ".csv"))
  out_snp   <- file.path(save_folder, paste0("coloc_SNP", suffix, ".csv"))

  data.table::fwrite(final_coloc, out_coloc, row.names = FALSE)
  data.table::fwrite(final_snp, out_snp, row.names = FALSE)

  rlang::inform("Done.")
}


